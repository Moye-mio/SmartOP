# 论文要解决什么问题呢？

对于一个已发布的3D模型，如何将其重建成可供CAD软件编辑的参数化模型？

# 论文的基本思想

[CSG（constructive solid geometry）](https://blog.csdn.net/libing_zeng/article/details/54865628)是一种3D模型参数化表示常用的方法。它是一种通过在基本图元上进行集合运算以建造复杂3D模型的树结构。

本文的基本思想是CSG的逆向应用，通过检测一个3D模型的基本图元及其之间的集合运算关系，生成此3D模型的CSG树，以此达到参数化表示的目的，生成的参数化模型即可在CAD软件中进行编辑。

# 论文的难点及创新点

本文将CSG树结构理解为计算机程序的结合，因此将CSG树的生成问题转化为了一个程序合成问题。更具体来说，考虑到对大规模问题的处理和可扩展性，本文选用程序合成中基于约束的合成算法来实现。

## 难点

将CSG树的生成问题转化为基于约束的合成问题需要面临三大问题：

**首先**，基于约束的合成算法的工作环境要求是离散域，但3D模型中包含有连续型参数（例如基本图元的范围）。

**其次**，检验合成程序是否满足约束条件是基于约束的合成算法的必要步骤。在本文中，约束条件为合成的CSG模型在空间中所占的体积必须与输入模型相同。如何把基于语言描述的约束条件转化为程序可以理解的约束条件呢？

**最后**，嘈杂的输入模型可能会导致无法找到适合的CSG程序。

## 创新点

针对难点问题，本文通过以下创新点来解决：

1.如何将连续型参数离散化？

本文通过定义一个指定的基本图元集合，**将3D模型通过这些指定的基本图元来表示**，以此将复杂的、连续的模型转变为离散的、简单的基本图元的集合。

2.如何把基于语言描述的约束条件转化为程序可以理解的约束条件？

本文通过在3D模型的包围盒中均匀采样，**当且仅当一个点若在输入模型的内部，它肯定也在输出模型的内部时，生成的CSG才满足约束条件**。

3.当**输入模型不完整**或**指定的基本图元无法精确重建输入模型**时，可能导致点采样时无法分清某点是否应该为内部点。本文通过将该点的标签设置成其所属的区域中大部分的点的标签来解决此问题。这样最小化了输出模型与输入模型之间的差异。

# 算法

![图片](pic\InverseCSG\pipeline.png)

## 输入

网格模型***M***

## **输出**

一个CSG 树，满足以下要求：

![图片](pic\InverseCSG\output.png)

其中，***Complexity***是CSG树节点的数目，p是采样点。

## 算法流程

在此说明，本文的基本图元集合指定为{球体，圆柱体，长方体，圆环面}，集合运算定义为{并，交，减}。实际应用中，可通过需要增减。

### 基本图元提取

此步的目标是提取出基本立体图元。首先，通过RANSAC和graph-cut算法来提取**表面图元**，然后推断存在于模型内部的面。收集完所有表面图元后，通过扩展所有表面图元的边界至无限大，相交的部分即组成对应的**立体图元**。

#### 提取表面图元

第一步，通过多次运行RANSAC算法来提取各种尺度的表面图元，例如球面、平面或圆柱面。

第二步，将第一步所有收集到的表面图元作为集合$$\{f1，f2,...\}$$,然后在模型表面上定义一个图$$G=\{V,E\}$$,其中，模型的每一个三角面片是一个节点$$v_{i}$$，相邻两节点定义一条边$$e_{ij}$$。

然后，发现一种图切方式，分配$$f$$给每一个节点$$v_{i}$$，并使得以下能量最小：

![图片](pic\InverseCSG\E.png)

其中，每一个节点的$$E_{unary}$$定义如下，$$f$$为分配给节点$$v_{i}$$的表面图元：

![图片](pic\InverseCSG\Eunary.png)

每一条边的$$E_{binary}$$定义为如下，$$f_{i}$$与$$f_{j}$$为分配给$$v_{i}$$和$$v_{j}$$的表面图元：

![图片](pic\InverseCSG\Ebinary.png)

$$E_{label}$$定义如下，可剔除生成的多余的图元：

![图片](pic\InverseCSG\Elabel.png)

$$\alpha$$和$$\beta$$分别代表三角面片之间所**分配图元的相似性**与**更少数量的表面图元**的权重，允许用户自行权衡定义。

#### 添加辅助面

上述算法只能检测可见的表面图元，为了更好地建造立体图元，需要推断出模型内部隐藏的面。本文通过[[Separation for boundary to CSG conversion]](https://xueshu.baidu.com/usercenter/paper/show?paperid=48dee6cee51ded7b22528e8dd9399738)中的方法，添加辅助面，来推断隐藏的面，得到更完整的表面图元信息。

#### 建造立体图元

第一步中提取出的表面单元使用边界表示法来表示：$$f(x)=0,x\in R^{3}$$。

在此步中，我们将其表示为$$f(x)\geq0,x\in R^{3}$$。然后，表面图元相交的闭区域，即为建造所得的立体图元。例如，三对并行平面相交，即可构成一个长方体。

经过基本图元提取，我们得到了离散的基本立体图元的集合。

### 采样

对输入模型的包围盒进行均匀采样，然后在每一个交叉平面所切割的区域（canonical intersection term）中选取一个代表点。根据这些代表点是否在输入模型内外，分为$$P^{+}$$或$$P^{-}$$两个集合。

处理后，约束条件变为：

![图片](pic\InverseCSG\sampling.png)

即只需判断$$P^{+}$$是否都在输出模型内，$$P^{-}$$是否都在输出模型外。

若遇到嘈杂的输入时，可能无法明确某点的内外位置。这时可采取此标准交叉项区域中大多数采样点的标签来表示此点。这样可最小化输出模型与输入模型的误差。

此时，经过预处理后，问题转变为一个具有有限约束的程序合成问题。

### 程序合成

#### 算法1-暴力

最简单粗暴的算法为直接把集合中的所有点当作约束，遍历所有的代表点集合，拼接他们的区域，输出一个CSG树。

![图片](pic\InverseCSG\algorithm1.png)

但这样处理的区域过多。例如若问题空间产生n个平面来切割空间，将得到$$O(n^{3})$$个闭区域。计算开销极大。

#### 算法2-针对小尺度

![image-20211101213954269](pic\InverseCSG\algorithm2.png)

算法1做法是把所有的点当作约束，这样解算器开销很大。

算法2的思路是：

不用去考虑所有的点，只需要抽一些点来作为约束去给解算器来生成程序。

但这样不是考虑所有点生成的程序肯定有可能是不符合最终需求的。

所以再让检查器去检查这个生成的程序，所有的点是不是都被满足了。

这样，增加一个检索的微小代价，大大缓解了计算能力这个大矛盾。

#### 算法3-针对大尺度（最终算法）

![图片](pic\InverseCSG\algorithm3.png)

算法3的思路在于，将一个很大的mesh切割成一个个小部分，这样每个小部分就可以直接调用算法2来处理。最后把每个小部分的CSG树拼接，就是最终的结果。本文中运用hierarchical

agglomerative clustering (HAC)来进行切割划分，也可使用其他的算法来划分，最好划分的小块都有意义。

运行过程中，若在某一部分运行失败，则继续切割这一部分到更小的部分，再次调用算法2。迭代处理直到成功。

若切割到只有1个代表点，则无需调用解算器，也即算法2，直接用算法1暴力求解即可。

### 后处理

#### 简化

第一步，合并位置、朝向、参数极其相似的图元，去掉多余的图元。

第二步，合并同类的、等价的集合运算符，即$$（A\cup B）\cup B$$等价于$$（A\cup B）$$，可去除多余的部分。

第三步，合并不同类的、等价的运算符。即$$（A\cup B）\cap B$$等价于$$B$$。迭代进行，直到

合并过程中，被合并的节点以下的子树即被清除。

#### 利用对称性

上述算法输出的CSG树，每个节点都是独立的。可参数进行对称性检测，将具有对称性的节点重新参数化，这样用户编辑时，便可利用对称性，仅修改一个参数，却实现对称编辑的效果。







